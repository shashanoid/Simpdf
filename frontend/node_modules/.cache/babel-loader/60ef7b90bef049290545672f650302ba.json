{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cleanupSemantic = exports.DIFF_INSERT = exports.DIFF_DELETE = exports.DIFF_EQUAL = exports.Diff = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\n\n\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\n\nexports.DIFF_EQUAL = DIFF_EQUAL;\n\nclass Diff {\n  constructor(op, text) {\n    _defineProperty(this, 0, void 0);\n\n    _defineProperty(this, 1, void 0);\n\n    this[0] = op;\n    this[1] = text;\n  }\n\n}\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\n\n\nexports.Diff = Diff;\n\nvar diff_commonPrefix = function diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\n\n\nvar diff_commonSuffix = function diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\n\n\nvar diff_commonOverlap_ = function diff_commonOverlap_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length; // Eliminate the null case.\n\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  } // Truncate the longer string.\n\n\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n\n  var text_length = Math.min(text1_length, text2_length); // Quick check for the worst case.\n\n  if (text1 == text2) {\n    return text_length;\n  } // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\n\n  var best = 0;\n  var length = 1;\n\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n\n    if (found == -1) {\n      return best;\n    }\n\n    length += found;\n\n    if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\n\nvar diff_cleanupSemantic = function diff_cleanupSemantic(diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n  /** @type {?string} */\n\n  var lastEquality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n\n  var length_insertions1 = 0;\n  var length_deletions1 = 0; // Number of characters that changed after the equality.\n\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      } // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n\n\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)); // Change second copy to insert.\n\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.\n\n        equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).\n\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // Normalize the diff.\n\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n\n  diff_cleanupSemanticLossless(diffs); // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n\n  pointer = 1;\n\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n\n      pointer++;\n    }\n\n    pointer++;\n  }\n};\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\n\nexports.cleanupSemantic = diff_cleanupSemantic;\n\nvar diff_cleanupSemanticLossless = function diff_cleanupSemanticLossless(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    } // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n\n\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1]; // First, shift the edit as far left as possible.\n\n      var commonOffset = diff_commonSuffix(equality1, edit);\n\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      } // Second, step character by character right, looking for the best fit.\n\n\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2); // The >= encourages trailing rather than leading whitespace on edits.\n\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n\n        diffs[pointer][1] = bestEdit;\n\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n\n    pointer++;\n  }\n}; // Define some regex patterns for matching boundaries.\n\n\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupMerge = function diff_cleanupMerge(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            } // Factor out any common suffixies.\n\n\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          } // Delete the offending records and add the merged ones.\n\n\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  } // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\n\n  var changes = false;\n  pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // If shifts were made, the diff needs reordering and another shift sweep.\n\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};","map":{"version":3,"sources":["/Users/shashwatsingh/Desktop/simpdf/frontend/node_modules/jest-diff/build/cleanupSemantic.js"],"names":["Object","defineProperty","exports","value","cleanupSemantic","DIFF_INSERT","DIFF_DELETE","DIFF_EQUAL","Diff","_defineProperty","obj","key","enumerable","configurable","writable","constructor","op","text","diff_commonPrefix","text1","text2","charAt","pointermin","pointermax","Math","min","length","pointermid","pointerstart","substring","floor","diff_commonSuffix","pointerend","diff_commonOverlap_","text1_length","text2_length","text_length","best","pattern","found","indexOf","diff_cleanupSemantic","diffs","changes","equalities","equalitiesLength","lastEquality","pointer","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","splice","diff_cleanupMerge","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","push","count_delete","count_insert","text_delete","text_insert","commonlength","pop"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.cleanupSemantic = exports.DIFF_INSERT = exports.DIFF_DELETE = exports.DIFF_EQUAL = exports.Diff = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\n\nexports.DIFF_EQUAL = DIFF_EQUAL;\n\nclass Diff {\n  constructor(op, text) {\n    _defineProperty(this, 0, void 0);\n\n    _defineProperty(this, 1, void 0);\n\n    this[0] = op;\n    this[1] = text;\n  }\n}\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\n\nexports.Diff = Diff;\n\nvar diff_commonPrefix = function diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\n\nvar diff_commonSuffix = function diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (\n    !text1 ||\n    !text2 ||\n    text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)\n  ) {\n    return 0;\n  } // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  return pointermid;\n};\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\n\nvar diff_commonOverlap_ = function diff_commonOverlap_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length; // Eliminate the null case.\n\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  } // Truncate the longer string.\n\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n\n  var text_length = Math.min(text1_length, text2_length); // Quick check for the worst case.\n\n  if (text1 == text2) {\n    return text_length;\n  } // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\n  var best = 0;\n  var length = 1;\n\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n\n    if (found == -1) {\n      return best;\n    }\n\n    length += found;\n\n    if (\n      found == 0 ||\n      text1.substring(text_length - length) == text2.substring(0, length)\n    ) {\n      best = length;\n      length++;\n    }\n  }\n};\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupSemantic = function diff_cleanupSemantic(diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n  /** @type {?string} */\n\n  var lastEquality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n\n  var length_insertions1 = 0;\n  var length_deletions1 = 0; // Number of characters that changed after the equality.\n\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      } // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n\n      if (\n        lastEquality &&\n        lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1) &&\n        lastEquality.length <= Math.max(length_insertions2, length_deletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(\n          equalities[equalitiesLength - 1],\n          0,\n          new Diff(DIFF_DELETE, lastEquality)\n        ); // Change second copy to insert.\n\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.\n\n        equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).\n\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // Normalize the diff.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n\n  diff_cleanupSemanticLossless(diffs); // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n\n  pointer = 1;\n\n  while (pointer < diffs.length) {\n    if (\n      diffs[pointer - 1][0] == DIFF_DELETE &&\n      diffs[pointer][0] == DIFF_INSERT\n    ) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n\n      if (overlap_length1 >= overlap_length2) {\n        if (\n          overlap_length1 >= deletion.length / 2 ||\n          overlap_length1 >= insertion.length / 2\n        ) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))\n          );\n          diffs[pointer - 1][1] = deletion.substring(\n            0,\n            deletion.length - overlap_length1\n          );\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (\n          overlap_length2 >= deletion.length / 2 ||\n          overlap_length2 >= insertion.length / 2\n        ) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))\n          );\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(\n            0,\n            insertion.length - overlap_length2\n          );\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n\n      pointer++;\n    }\n\n    pointer++;\n  }\n};\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nexports.cleanupSemantic = diff_cleanupSemantic;\n\nvar diff_cleanupSemanticLossless = function diff_cleanupSemanticLossless(\n  diffs\n) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    } // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n\n    return 0;\n  }\n\n  var pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1]; // First, shift the edit as far left as possible.\n\n      var commonOffset = diff_commonSuffix(equality1, edit);\n\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      } // Second, step character by character right, looking for the best fit.\n\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore =\n        diff_cleanupSemanticScore_(equality1, edit) +\n        diff_cleanupSemanticScore_(edit, equality2);\n\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score =\n          diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2); // The >= encourages trailing rather than leading whitespace on edits.\n\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n\n        diffs[pointer][1] = bestEdit;\n\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n\n    pointer++;\n  }\n}; // Define some regex patterns for matching boundaries.\n\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n\nvar diff_cleanupMerge = function diff_cleanupMerge(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              if (\n                pointer - count_delete - count_insert > 0 &&\n                diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL\n              ) {\n                diffs[\n                  pointer - count_delete - count_insert - 1\n                ][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(\n                  0,\n                  0,\n                  new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))\n                );\n                pointer++;\n              }\n\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            } // Factor out any common suffixies.\n\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) +\n                diffs[pointer][1];\n              text_insert = text_insert.substring(\n                0,\n                text_insert.length - commonlength\n              );\n              text_delete = text_delete.substring(\n                0,\n                text_delete.length - commonlength\n              );\n            }\n          } // Delete the offending records and add the merged ones.\n\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  } // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\n  var changes = false;\n  pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(\n          diffs[pointer][1].length - diffs[pointer - 1][1].length\n        ) == diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(\n            0,\n            diffs[pointer][1].length - diffs[pointer - 1][1].length\n          );\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n\n    pointer++;\n  } // If shifts were made, the diff needs reordering and another shift sweep.\n\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}