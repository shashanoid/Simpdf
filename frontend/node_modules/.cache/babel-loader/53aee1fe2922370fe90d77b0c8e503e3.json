{"ast":null,"code":"/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange.cache = {};\n\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nmodule.exports = toRegexRange;","map":{"version":3,"sources":["/Users/shashwatsingh/Desktop/simpdf/frontend/node_modules/http-proxy-middleware/node_modules/to-regex-range/index.js"],"names":["isNumber","require","toRegexRange","min","max","options","TypeError","String","opts","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","result","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","length","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","concat","join","splitToRanges","nines","zeros","stop","countNines","stops","Set","add","countZeros","sort","compare","rangeToPattern","start","pattern","count","digits","zipped","zip","i","startDigit","stopDigit","toCharacterClass","tok","ranges","tokens","prev","obj","pop","push","string","toQuantifier","padZeros","arr","comparison","prefix","intersection","ele","contains","key","val","some","len","Number","slice","repeat","integer","pow","str","test","value","diff","clearCache","module","exports"],"mappings":"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","sourcesContent":["/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n"]},"metadata":{},"sourceType":"script"}