{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst utils = require('./utils');\n/**\n * Constants\n */\n\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n/**\n * Create the message for a syntax error\n */\n\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n\n  const peek = state.peek = (n = 1) => input[state.index + n];\n\n  const advance = state.advance = () => input[++state.index];\n\n  const remaining = () => input.slice(state.index + 1);\n\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value],\n      conditions: 1,\n      inner: ''\n    };\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n  /**\n   * Fast paths\n   */\n\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n    /**\n     * Escaped characters\n     */\n\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * Double quotes\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\n     * Square brackets\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({\n        value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n    /**\n     * Braces\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = `\\\\}`;\n        state.output = out;\n\n        for (const t of toks) {\n          state.output += t.output || t.value;\n        }\n      }\n\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n    /**\n     * Pipes\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Commas\n     */\n\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n    /**\n     * Slashes\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Dots\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Question marks\n     */\n\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\n     * Exclamation\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n    /**\n     * Plus\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Stars\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/shashwatsingh/Desktop/simpdf/frontend/node_modules/picomatch/lib/parse.js"],"names":["constants","require","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","win32","isWindows","PLATFORM_CHARS","globChars","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","extglobStar","includes","test","negatedExtglob","fastpaths","backslashes","replace","m","esc","chars","first","rest","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","isGroup","supportsLookbehinds","Error","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","NO_DOTS","slashDot","create","str","source","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n\n\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = `\\\\}`;\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}