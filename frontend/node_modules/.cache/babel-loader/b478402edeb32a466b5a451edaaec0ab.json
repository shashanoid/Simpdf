{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst braces = require('braces');\n\nconst picomatch = require('picomatch');\n\nconst utils = require('picomatch/lib/utils');\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options,\n      onResult\n    }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options,\n    onResult\n  });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n\n  return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options,\n    contains: true\n  });\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n\n  for (let key of keys) res[key] = obj[key];\n\n  return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options,\n    capture: true\n  });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n\n  return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces(pattern, options);\n};\n/**\n * Expand braces\n */\n\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options,\n    expand: true\n  });\n};\n/**\n * Expose micromatch\n */\n\n\nmodule.exports = micromatch;","map":{"version":3,"sources":["/Users/shashwatsingh/Desktop/simpdf/frontend/node_modules/http-proxy-middleware/node_modules/micromatch/index.js"],"names":["util","require","braces","picomatch","utils","isEmptyString","val","micromatch","list","patterns","options","concat","omit","Set","keep","items","negatives","onResult","state","add","output","i","length","isMatch","String","negated","negatedExtglob","item","matched","match","delete","result","matches","filter","has","failglob","Error","join","nonull","nullglob","unescape","map","p","replace","matcher","pattern","str","any","not","push","includes","contains","TypeError","inspect","Array","isArray","some","startsWith","slice","matchKeys","obj","isObject","keys","Object","res","key","every","all","capture","glob","input","posix","isWindows","regex","makeRe","exec","toPosixSlashes","v","args","scan","parse","nobrace","test","braceExpand","expand","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options, onResult });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n"]},"metadata":{},"sourceType":"script"}