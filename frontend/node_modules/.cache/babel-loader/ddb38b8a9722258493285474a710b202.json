{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n// Input callback function compares items at indexes in the sequences.\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\n\nconst pkg = 'diff-sequences'; // for error messages\n\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\n\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\n\n\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\n\n\nconst extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n\n  aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF are odd when d is odd and even when d is even.\n\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n\n  return iMaxF;\n}; // A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\n\n\nconst extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n\n  aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR are odd when d is odd and even when d is even.\n\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);\n  }\n\n  return iMaxR;\n}; // A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\n\n\nconst extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert ? aLastPrev // vertical to insert from b\n    : aLastPrev + 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2; // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1); // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n\n        const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n\n        division.nCommonFollowing = nCommonF;\n\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\n\n\nconst extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert ? aLastPrev // vertical to insert from b\n    : aLastPrev - 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2; // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n\n        division.nChangeFollowing = d - 1;\n\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1); // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n\n          const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);\n          division.nCommonFollowing = nCommonF;\n\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\n\n\nconst divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart; // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n\n  const baDeltaLength = bLength - aLength; // Optimization: max diagonal in graph intersects corner of shorter side.\n\n  let iMaxF = aLength;\n  let iMaxR = aLength; // Initialize no changes yet in forward or reverse direction:\n\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if ( // If a reverse path overlaps a forward path in the same diagonal,\n      // return a division of the index intervals at the middle change.\n      extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2; // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if ( // If a forward path overlaps a reverse path in the same diagonal,\n      // return a division of the index intervals at the middle change.\n      extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {\n        return;\n      }\n    }\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);\n}; // Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\n\n\nconst findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const _callbacks$ = callbacks[0],\n            foundSubsequence = _callbacks$.foundSubsequence,\n            isCommon = _callbacks$.isCommon;\n      callbacks[1] = {\n        foundSubsequence: function (_foundSubsequence) {\n          function foundSubsequence(_x, _x2, _x3) {\n            return _foundSubsequence.apply(this, arguments);\n          }\n\n          foundSubsequence.toString = function () {\n            return _foundSubsequence.toString();\n          };\n\n          return foundSubsequence;\n        }((nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        }),\n        isCommon: function (_isCommon) {\n          function isCommon(_x4, _x5) {\n            return _isCommon.apply(this, arguments);\n          }\n\n          isCommon.toString = function () {\n            return _isCommon.toString();\n          };\n\n          return isCommon;\n        }((bIndex, aIndex) => isCommon(aIndex, bIndex))\n      };\n    }\n\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n\n  const _callbacks = callbacks[transposed ? 1 : 0],\n        foundSubsequence = _callbacks.foundSubsequence,\n        isCommon = _callbacks.isCommon; // Divide the index intervals at the middle change.\n\n  divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);\n  const nChangePreceding = division.nChangePreceding,\n        aEndPreceding = division.aEndPreceding,\n        bEndPreceding = division.bEndPreceding,\n        nCommonPreceding = division.nCommonPreceding,\n        aCommonPreceding = division.aCommonPreceding,\n        bCommonPreceding = division.bCommonPreceding,\n        nCommonFollowing = division.nCommonFollowing,\n        aCommonFollowing = division.aCommonFollowing,\n        bCommonFollowing = division.bCommonFollowing,\n        nChangeFollowing = division.nChangeFollowing,\n        aStartFollowing = division.aStartFollowing,\n        bStartFollowing = division.bStartFollowing; // Unless either index interval is empty, they might contain common items.\n\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);\n  } // Return common subsequences that are adjacent to the middle change.\n\n\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  } // Unless either index interval is empty, they might contain common items.\n\n\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);\n  }\n};\n\nconst validateLength = (name, arg) => {\n  const type = typeof arg;\n\n  if (type !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a number`);\n  }\n\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\n\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n}; // Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\n\n\nvar _default = (aLength, bLength, isCommon, foundSubsequence) => {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence); // Count common items from the start in the forward direction.\n\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  } // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n\n\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF; // Count common items from the end in the reverse direction.\n\n    const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon); // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR; // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n\n    const nCommonFR = nCommonF + nCommonR;\n\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n\n      const transposed = false; // call the original unwrapped functions\n\n      const callbacks = [{\n        foundSubsequence,\n        isCommon\n      }]; // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n\n      const aIndexesF = [NOT_YET_SET]; // from the end at bottom right in the reverse direction:\n\n      const aIndexesR = [NOT_YET_SET]; // Initialize one object as output of all calls to divide function.\n\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      }; // Find and return common subsequences in the trimmed index intervals.\n\n      findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);\n    }\n\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n};\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/shashwatsingh/Desktop/simpdf/frontend/node_modules/diff-sequences/build/index.js"],"names":["Object","defineProperty","exports","value","default","pkg","NOT_YET_SET","countCommonItemsF","aIndex","aEnd","bIndex","bEnd","isCommon","nCommon","countCommonItemsR","aStart","bStart","extendPathsF","d","bF","aIndexesF","iMaxF","iF","kF","aFirst","aIndexPrev1","nF","extendPathsR","bR","aIndexesR","iMaxR","iR","kR","nR","extendOverlappablePathsF","division","aLength","bLength","baDeltaLength","kMinOverlapF","kMaxOverlapF","insert","aLastPrev","bFirst","nCommonF","aLast","bLastPrev","nCommonR","aIndexPrevFirst","bIndexPrevFirst","aEndPreceding","bEndPreceding","nChangePreceding","nCommonPreceding","aCommonPreceding","bCommonPreceding","nCommonFollowing","aCommonFollowing","bCommonFollowing","aStartFollowing","bStartFollowing","nChangeFollowing","extendOverlappablePathsR","kMinOverlapR","kMaxOverlapR","bLast","divide","nChange","dMin","dMax","Error","findSubsequences","transposed","callbacks","length","_callbacks$","foundSubsequence","_foundSubsequence","_x","_x2","_x3","apply","arguments","toString","bCommon","aCommon","_isCommon","_x4","_x5","tStart","tEnd","_callbacks","validateLength","name","arg","type","TypeError","Number","isSafeInteger","RangeError","validateCallback","_default","nCommonFR"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n// Input callback function compares items at indexes in the sequences.\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\nconst pkg = 'diff-sequences'; // for error messages\n\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\n\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\n\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n\n  return nCommon;\n}; // A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\n\nconst extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n\n  aIndexesF[iF] += countCommonItemsF(\n    aFirst + 1,\n    aEnd,\n    bF + aFirst - kF + 1,\n    bEnd,\n    isCommon\n  ); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF are odd when d is odd and even when d is even.\n\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] =\n      aFirst +\n      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n\n  return iMaxF;\n}; // A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\n\nconst extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n\n  aIndexesR[iR] -= countCommonItemsR(\n    aStart,\n    aFirst - 1,\n    bStart,\n    bR + aFirst - kR - 1,\n    isCommon\n  ); // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR are odd when d is odd and even when d is even.\n\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    } // To get last point of path segment, move along diagonal of common items.\n\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] =\n      aFirst -\n      countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n  }\n\n  return iMaxR;\n}; // A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\n\nconst extendOverlappablePathsF = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nF = d < iMaxF ? d : iMaxF; // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev + 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bFirst + 1,\n      bEnd,\n      isCommon\n    );\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2; // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1); // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n\n        const nCommonR = countCommonItemsR(\n          aStart,\n          aLastPrev,\n          bStart,\n          bLastPrev,\n          isCommon\n        );\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n\n        division.nCommonFollowing = nCommonF;\n\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\n\nconst extendOverlappablePathsR = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division\n) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n  // Range of diagonals in which forward and reverse paths might overlap.\n\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n\n  const nR = d < iMaxR ? d : iMaxR; // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev - 1; // horizontal to delete from a\n    // To get last point of path segment, move along diagonal of common items.\n\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bFirst - 1,\n      isCommon\n    );\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2; // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n\n        division.nCommonPreceding = nCommonR;\n\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n\n        division.nChangeFollowing = d - 1;\n\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1); // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n\n          const nCommonF = countCommonItemsF(\n            aLastPrev,\n            aEnd,\n            bLastPrev,\n            bEnd,\n            isCommon\n          );\n          division.nCommonFollowing = nCommonF;\n\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\n\nconst divide = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  aIndexesR,\n  division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart; // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n\n  const baDeltaLength = bLength - aLength; // Optimization: max diagonal in graph intersects corner of shorter side.\n\n  let iMaxF = aLength;\n  let iMaxR = aLength; // Initialize no changes yet in forward or reverse direction:\n\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n        // If a reverse path overlaps a forward path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsR(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2; // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(\n        d - 1,\n        aStart,\n        bStart,\n        bR,\n        isCommon,\n        aIndexesR,\n        iMaxR\n      );\n\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n        // If a forward path overlaps a reverse path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsF(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  }\n  /* istanbul ignore next */\n\n  throw new Error(\n    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n  );\n}; // Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\n\nconst findSubsequences = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  transposed,\n  callbacks,\n  aIndexesF,\n  aIndexesR,\n  division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const _callbacks$ = callbacks[0],\n        foundSubsequence = _callbacks$.foundSubsequence,\n        isCommon = _callbacks$.isCommon;\n      callbacks[1] = {\n        foundSubsequence: (function(_foundSubsequence) {\n          function foundSubsequence(_x, _x2, _x3) {\n            return _foundSubsequence.apply(this, arguments);\n          }\n\n          foundSubsequence.toString = function() {\n            return _foundSubsequence.toString();\n          };\n\n          return foundSubsequence;\n        })((nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        }),\n        isCommon: (function(_isCommon) {\n          function isCommon(_x4, _x5) {\n            return _isCommon.apply(this, arguments);\n          }\n\n          isCommon.toString = function() {\n            return _isCommon.toString();\n          };\n\n          return isCommon;\n        })((bIndex, aIndex) => isCommon(aIndex, bIndex))\n      };\n    }\n\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n\n  const _callbacks = callbacks[transposed ? 1 : 0],\n    foundSubsequence = _callbacks.foundSubsequence,\n    isCommon = _callbacks.isCommon; // Divide the index intervals at the middle change.\n\n  divide(\n    nChange,\n    aStart,\n    aEnd,\n    bStart,\n    bEnd,\n    isCommon,\n    aIndexesF,\n    aIndexesR,\n    division\n  );\n  const nChangePreceding = division.nChangePreceding,\n    aEndPreceding = division.aEndPreceding,\n    bEndPreceding = division.bEndPreceding,\n    nCommonPreceding = division.nCommonPreceding,\n    aCommonPreceding = division.aCommonPreceding,\n    bCommonPreceding = division.bCommonPreceding,\n    nCommonFollowing = division.nCommonFollowing,\n    aCommonFollowing = division.aCommonFollowing,\n    bCommonFollowing = division.bCommonFollowing,\n    nChangeFollowing = division.nChangeFollowing,\n    aStartFollowing = division.aStartFollowing,\n    bStartFollowing = division.bStartFollowing; // Unless either index interval is empty, they might contain common items.\n\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(\n      nChangePreceding,\n      aStart,\n      aEndPreceding,\n      bStart,\n      bEndPreceding,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  } // Return common subsequences that are adjacent to the middle change.\n\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  } // Unless either index interval is empty, they might contain common items.\n\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(\n      nChangeFollowing,\n      aStartFollowing,\n      aEnd,\n      bStartFollowing,\n      bEnd,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n};\n\nconst validateLength = (name, arg) => {\n  const type = typeof arg;\n\n  if (type !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a number`);\n  }\n\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\n\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n}; // Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\n\nvar _default = (aLength, bLength, isCommon, foundSubsequence) => {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence); // Count common items from the start in the forward direction.\n\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  } // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF; // Count common items from the end in the reverse direction.\n\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aLength - 1,\n      bStart,\n      bLength - 1,\n      isCommon\n    ); // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR; // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n\n    const nCommonFR = nCommonF + nCommonR;\n\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n\n      const transposed = false; // call the original unwrapped functions\n\n      const callbacks = [\n        {\n          foundSubsequence,\n          isCommon\n        }\n      ]; // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n\n      const aIndexesF = [NOT_YET_SET]; // from the end at bottom right in the reverse direction:\n\n      const aIndexesR = [NOT_YET_SET]; // Initialize one object as output of all calls to divide function.\n\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      }; // Find and return common subsequences in the trimmed index intervals.\n\n      findSubsequences(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n};\n\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}